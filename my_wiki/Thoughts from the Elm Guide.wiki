= Thoughts =
== Core Language ==
Are type annotations not a thing? Or is it like Haskell?

From the *List* section, I noticed the functions on lists were prefixed with `List`.
This is different than Haskell where we would either have the function available by default (via Prelude imports) or import the function itself, not referencing the whole module, although I guess you can still do that.

At the bottom the author mentions Elm's way of making new objects/things as updates instead of destructively updating an object/thing is efficient through "sharing as much content as possible" I wonder what that means...

== The Elm Architecture ==
People refere to the Elm architecture as TEA. It consists of the following three pieces:
- Model
- A system for updating the model
- view 
So it's similar to MVC, definitely letter wise (badum-tsst!).

=== Buttons ===
I see and appreciate the value of having types representing actions. The exercise of adding a "Reset" feature displayed how trivial this is. Sure, it's a small example, but imagine in a bigger context! And the readability!

=== Form ===
One bit that was tripping me up is how a type can seem like a function itself. For instance, the onChange events are handled by what seems like half a type (i.e. `Name`). This then takes whatever input and returns the full `Name String` bit. 

== Types ==
=== Type Aliases ===
Just like in Haskell!

=== Custom Types ===
Elm treats types like Haskell which is pretty awesome! You can make `custom types` which is Elm's name for `algebraic datatypes (ADT)`.

=== Pattern Matching ===
Here Elm is a bit different than Haskell. They use `case` syntax which is similar to Haskell. Here's a snippet from the guide:
`
toName : User -> String
toName user =
  case user of
    Regular name _ ->
      name
      
    Visitor name ->
      name
`

== Side Note << Appendix -- Types as Sets ==
Here the author/s talk about cardinality! Same stuff as discussed in Haskell guides.
One point that I did find valuable is the concept of *revisiting and revising types so they match their real world values*.


== Error Handling ==
=== Maybe ===
A very good point was made:
If you're using `Maybe` a lot it will be worthwhile to examine your data types and perhaps use custom classes instead. This way you can avoid conditional code to handle the situations and just rely on pattern matching. Plus it will describe the application better from a higher-level.

=== Result ===
This is interesting. There's a `Result` type whose definition is the following:
`
type Result error value
  = Ok value
  | Err error
`
This is a way to add messages to errors to provide more detailed errors or different messages based on the type of error.

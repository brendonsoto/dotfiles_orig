# Project 5
- [X] [[Memory]]
- [X] [[CPU]]
- [X] Computer


## Reflections
(2018/Mar/9)

Upon completing Chapter/Project 5 I am once again blown away at how so much complexity can be conveyed by 1's and 0's.

Learning about the von Neumann architecture was pretty dope. It's not crazy to think most computers follow a similar underlying structure, but it's pretty nuts to me how it can be boiled down to a few components, four in the case of this book! I haven't checked other sources for von Neumann architecture so I'm not sure if there's more or less to the idea, but it's still pretty amazing. Thinking about the architecture makes me reflect on the work I do now. I wonder if the apps I work on could be broken down into simpler pieces, as if there's a more general framework lying underneath all of this. Of course a lot goes into the individual pieces, as was the case for building these computer chips, but I'm thinking that maybe my current approach to development is not utilizing abstractions as building blocks in an efficient way, like I could be building better things by reusing what I'm making. Great systems take time to conceptualize and realize and time, unfortunately, is a sparse resource in work-related projects.

The Memory chip was like a nice refresher of the previous chapter's projects. Building the CPU was really fun and the resulting computer was a sinch! I followed the recommended approach to building the CPU, as suggested by the book, since I figured it would be easier to debug if anything were to go wrong now or in the future. On second thought, I guess a different approach wouldn't have required much more work since it would be using the same underlying principles.

That's an interesting idea too, debugging on principles. So often I go into debugging by just trying to dive into the code without thinking much about _what_ is supposed to be happening, the big picture. It seems so tough to remember to zoom out when you're so zoomed in!

One thing that bothered me afterwards was I didn't think I had a great understanding of the CPU through without really trying to think of an implementation myself or trying to think of what the implementation would be like beforehand. That was an error on my part. I didn't think about what the architecture could be like until afterwards. Lesson learned though!

Even though it's all in software it's still so exciting to be able to say I've made a computer!
